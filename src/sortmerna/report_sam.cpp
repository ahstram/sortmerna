#include "report_sam.h"
#include "common.hpp"
#include "options.hpp"
#include "read.hpp"
#include "references.hpp"
#include "refstats.hpp"
#include "readfeed.hpp"

ReportSam::ReportSam(Runopts& opts) : Report(opts) {}

ReportSam::ReportSam(Readfeed& readfeed, Runopts& opts) : ReportSam(opts)
{
	init(readfeed, opts);
}

void ReportSam::init(Readfeed& readfeed, Runopts& opts)
{
	fv.resize(readfeed.num_splits);
	fsv.resize(readfeed.num_splits);
	// WORKDIR/out/aligned_0_PID.sam
	for (int i = 0; i < readfeed.num_splits; ++i) {
		std::string sfx1 = "_" + std::to_string(i);
		std::string sfx2 = opts.is_pid ? "_" + pid_str : "";
		fv[i] = opts.aligned_pfx.string() + sfx1 + sfx2 + ext;
		INFO("Testing file: ", std::filesystem::absolute(std::filesystem::path(fv[i])));
		fsv[i].open(fv[i]);
		fsv[i].close();
		if (!fsv[i]) {
			ERR("Failed stream on file ", fv[i]);
			exit(EXIT_FAILURE);
		}
	}
}

void ReportSam::append(int id, Read& read, References& refs, Runopts& opts)
{
	if (read.is03) read.flip34();

	// read did not align, output null string
	if (opts.is_print_all_reads && read.alignment.alignv.size() == 0)
	{
		// (1) Query
		fsv[id] << read.getSeqId();
		fsv[id] << "\t4\t*\t0\t0\t*\t*\t0\t0\t*\t*\n";
		return;
	}

	// read aligned, output full alignment
	// iterate read alignments
	for (int i = 0; i < read.alignment.alignv.size(); ++i)
	{
		if (read.alignment.alignv[i].index_num == refs.num
			&& read.alignment.alignv[i].part == refs.part)
		{
			// (1) Query
			fsv[id] << read.getSeqId();
			// (2) flag Forward/Reversed
			if (!read.alignment.alignv[i].strand) fsv[id] << "\t16\t";
			else fsv[id] << "\t0\t";
			// (3) Subject
			fsv[id] << refs.buffer[read.alignment.alignv[i].ref_num].id;
			// (4) Ref start
			fsv[id] << "\t" << read.alignment.alignv[i].ref_begin1 + 1;
			// (5) mapq
			fsv[id] << "\t" << 255 << "\t";
			// (6) CIGAR
			// output the masked region at beginning of alignment
			if (read.alignment.alignv[i].read_begin1 != 0)
				fsv[id] << read.alignment.alignv[i].read_begin1 << "S";

			for (int c = 0; c < read.alignment.alignv[i].cigar.size(); ++c)
			{
				uint32_t letter = 0xf & read.alignment.alignv[i].cigar[c];
				uint32_t length = (0xfffffff0 & read.alignment.alignv[i].cigar[c]) >> 4;
				fsv[id] << length;
				if (letter == 0) fsv[id] << "M";
				else if (letter == 1) fsv[id] << "I";
				else fsv[id] << "D";
			}

			auto end_mask = read.sequence.size() - read.alignment.alignv[i].read_end1 - 1;
			// output the masked region at end of alignment
			if (end_mask > 0) fsv[id] << end_mask << "S";
			// (7) RNEXT, (8) PNEXT, (9) TLEN
			fsv[id] << "\t*\t0\t0\t";
			// (10) SEQ

			if (read.alignment.alignv[i].strand == read.reversed) // XNOR
				read.revIntStr();
			fsv[id] << read.get04alphaSeq();
			// (11) QUAL
			fsv[id] << "\t";
			// reverse-complement strand
			if (read.quality.size() > 0 && !read.alignment.alignv[i].strand)
			{
				std::reverse(read.quality.begin(), read.quality.end());
				fsv[id] << read.quality;
			}
			else if (read.quality.size() > 0) // forward strand
			{
				fsv[id] << read.quality;
				// FASTA read
			}
			else fsv[id] << "*";

			// (12) OPTIONAL FIELD: SW alignment score generated by aligner
			fsv[id] << "\tAS:i:" << read.alignment.alignv[i].score1;
			// (13) OPTIONAL FIELD: edit distance to the reference
			uint32_t mismatches = 0;
			uint32_t gaps = 0;
			uint32_t mid = 0;
			read.calcMismatchGapId(refs, i, mismatches, gaps, mid);
			fsv[id] << "\tNM:i:" << mismatches + gaps << "\n";
		}
	} // ~for read.alignments
} // ~ReportSam::append

void ReportSam::write_header(Runopts& opts)
{
	fsv[0] << "@HD\tVN:1.0\tSO:unsorted\n";

	// TODO: this line is taken from "Index::load_stats". To be finished (20171215).
#if 0
	for (uint16_t index_num = 0; index_num < (uint16_t)opts.indexfiles.size(); index_num++)
	{
		//@SQ header
		if (opts.yes_SQ) acceptedsam << "@SQ\tSN:" << s << "\tLN:" << len_seq << "\n";
		// number of nucleotide sequences in the reference file
		uint32_t num_sq = 0;
		stats.read(reinterpret_cast<char*>(&num_sq), sizeof(uint32_t));

		// loop through each @SQ
		for (uint32_t j = 0; j < num_sq; j++)
		{
			// length of the sequence id
			uint32_t len_id = 0;
			stats.read(reinterpret_cast<char*>(&len_id), sizeof(uint32_t));
			// the sequence id string
			std::string s(len_id + 1, 0); // AK
			std::vector<char> vs(s.begin(), s.end());
			stats.read(reinterpret_cast<char*>(&vs[0]), sizeof(char) * len_id);
			// the length of the sequence itself
			uint32_t len_seq = 0;
			stats.read(reinterpret_cast<char*>(&len_seq), sizeof(uint32_t));
			//		 @SQ header
			if (opts.yes_SQ) acceptedsam << "@SQ\tSN:" << s << "\tLN:" << len_seq << "\n";
		} // ~for
	} // ~for
#endif
	fsv[0] << "@PG\tID:sortmerna\tVN:1.0\tCL:" << opts.cmdline << std::endl;
} // ~ReportSam::write_header